   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  94               	.global	__vector_default
  96               	__vector_default:
   1:main.c        **** /*****************************************************************************
   2:main.c        **** *
   3:main.c        **** * AVRPROG compatible boot-loader
   4:main.c        **** * Version  : 0.85 (Dec. 2008)
   5:main.c        **** * Compiler : avr-gcc 4.1.2 / avr-libc 1.4.6
   6:main.c        **** * size     : depends on features and startup ( minmal features < 512 words)
   7:main.c        **** * by       : Martin Thomas, Kaiserslautern, Germany
   8:main.c        **** *            eversmith@heizung-thomas.de
   9:main.c        **** *            Additional code and improvements contributed by:
  10:main.c        **** *           - Uwe Bonnes
  11:main.c        **** *           - Bjoern Riemer
  12:main.c        **** *           - Olaf Rempel
  13:main.c        **** *
  14:main.c        **** * License  : Copyright (c) 2006-2008 M. Thomas, U. Bonnes, O. Rempel
  15:main.c        **** *            Free to use. You have to mention the copyright
  16:main.c        **** *            owners in source-code and documentation of derived
  17:main.c        **** *            work. No warranty! (Yes, you can insert the BSD
  18:main.c        **** *            license here)
  19:main.c        **** *
  20:main.c        **** * Tested with ATmega8, ATmega16, ATmega162, ATmega32, ATmega324P,
  21:main.c        **** *             ATmega644, ATmega644P, ATmega128, AT90CAN128
  22:main.c        **** *
  23:main.c        **** * - Initial versions have been based on the Butterfly bootloader-code
  24:main.c        **** *   by Atmel Corporation (Authors: BBrandal, PKastnes, ARodland, LHM)
  25:main.c        **** *
  26:main.c        **** ****************************************************************************
  27:main.c        **** *
  28:main.c        **** *  See the makefile and readme.txt for information on how to adapt 
  29:main.c        **** *  the linker-settings to the selected Boot Size (BOOTSIZE=xxxx) and 
  30:main.c        **** *  the MCU-type. Other configurations futher down in this file.
  31:main.c        **** *
  32:main.c        **** *  With BOOT_SIMPLE, minimal features and discarded int-vectors
  33:main.c        **** *  this bootloader has should fit into a a 512 word (1024, 0x400 bytes) 
  34:main.c        **** *  bootloader-section. 
  35:main.c        **** *
  36:main.c        **** ****************************************************************************/
  37:main.c        **** 
  38:main.c        **** /* Частота контроллера (кварца) */
  39:main.c        **** #ifndef F_CPU
  40:main.c        **** #define F_CPU 7372800
  41:main.c        **** //#define F_CPU (7372800/2)
  42:main.c        **** //#define F_CPU 1000000
  43:main.c        **** #endif
  44:main.c        **** 
  45:main.c        **** /* UART Скорость UART оптимально 19200 */
  46:main.c        **** //#define BAUDRATE 9600
  47:main.c        **** #define BAUDRATE 19200
  48:main.c        **** //#define BAUDRATE 115200
  49:main.c        **** 
  50:main.c        **** /* Режим двойной скорости UART (бит U2C)*/
  51:main.c        **** #define UART_DOUBLESPEED
  52:main.c        **** 
  53:main.c        **** /* Используется второй UART на mega128 / can128 / mega162 / mega324p / mega644p */
  54:main.c        **** #define UART_USE_SECOND
  55:main.c        **** 
  56:main.c        **** /* Тип устройства:
  57:main.c        ****    Для AVRProg выбирать BOOT 
  58:main.c        ****    Это корректное значение для bootloader.
  59:main.c        ****    avrdude может определить только part-code для ISP */
  60:main.c        **** #define DEVTYPE     DEVTYPE_BOOT
  61:main.c        **** // #define DEVTYPE     DEVTYPE_ISP
  62:main.c        **** 
  63:main.c        **** /*
  64:main.c        ****  * Выбор порта для кнопки входа в загрузчик
  65:main.c        ****  * Чтобы войти в загрузчик надо чтобы при запуске эта кнопка замыкала пин на землю
  66:main.c        ****  */
  67:main.c        **** #define BLPORT		PORTB
  68:main.c        **** #define BLDDR		DDRB
  69:main.c        **** #define BLPIN		PINB
  70:main.c        **** #define BLPNUM		PINB1
  71:main.c        **** 
  72:main.c        **** /*
  73:main.c        ****  * Выбор порта для индикатора работы загрузчика
  74:main.c        ****  * Светодиод горит - мы в загрузчике
  75:main.c        ****  */
  76:main.c        **** 
  77:main.c        **** #define ENABLE_BOOT_LED
  78:main.c        **** #define BIPORT		PORTB
  79:main.c        **** #define BIDDR		DDRB
  80:main.c        **** #define BIPIN		PINB
  81:main.c        **** #define BIPNUM		PINB0
  82:main.c        **** 
  83:main.c        **** 
  84:main.c        **** /*
  85:main.c        ****  * Выключить Собачий таймер на время загрузчика
  86:main.c        ****  */
  87:main.c        **** #define DISABLE_WDT_AT_STARTUP
  88:main.c        **** 
  89:main.c        **** /*
  90:main.c        ****  * Watchdog-reset is issued at exit 
  91:main.c        ****  * define the timeout-value here (see avr-libc manual)
  92:main.c        ****  */
  93:main.c        **** #define EXIT_WDT_TIME   WDTO_250MS
  94:main.c        **** 
  95:main.c        **** /*
  96:main.c        ****  * Выбор режима загрузчика
  97:main.c        ****  * SIMPLE-Mode - Загрузчик стартует когда нажата его кнопка
  98:main.c        ****  *   переход к основной программе осуществляется после сброса 
  99:main.c        ****  *   (кнопка должна быть отжата) либо по команде от программатора
 100:main.c        ****  *   При этом режиме вывод на кнопку конфигурируется как вход-с подтягом,
 101:main.c        ****  *   но при выходе из загрузчика все выставляется по умолчанию
 102:main.c        ****  * POWERSAVE-Mode - Startup is separated in two loops
 103:main.c        ****  *   which makes power-saving a little easier if no firmware
 104:main.c        ****  *   is on the chip. Needs more memory
 105:main.c        ****  * BOOTICE-Mode - для зашивки  JTAGICE файла upgrade.ebn в Мегу16.
 106:main.c        ****  *   что превращает ее в JTAG отладчик. Разумеется нужно добавить весь необходимый
 107:main.c        ****  *   обвяз на кристалл для этого. И частота должна быть везде прописана как 7372800
 108:main.c        ****  *   в F_CPU Для совместимости с родной прошивкой JTAG ICE
 109:main.c        ****  * WAIT-mode Bootloader ожидает команды на вход, если ее не было в течении промежутка времени
 110:main.c        ****  *   (который настраивается) то проихсодит переход к основной программе.
 111:main.c        ****  */
 112:main.c        **** #define START_SIMPLE
 113:main.c        **** //#define START_WAIT
 114:main.c        **** //#define START_POWERSAVE
 115:main.c        **** //#define START_BOOTICE
 116:main.c        **** 
 117:main.c        **** /* Команда для входа в загрузчик в START_WAIT */
 118:main.c        **** #define START_WAIT_UARTCHAR 'S'
 119:main.c        **** 
 120:main.c        **** /* Выдержка для START_WAIT mode ( t = WAIT_TIME * 10ms ) */
 121:main.c        **** #define WAIT_VALUE 500 /* сейчас: 300*10ms = 3000ms = 3sec */
 122:main.c        **** 
 123:main.c        **** /*
 124:main.c        ****  * enable/disable readout of fuse and lock-bits
 125:main.c        ****  * (AVRPROG has to detect the AVR correctly by device-code
 126:main.c        ****  * to show the correct information).
 127:main.c        ****  */
 128:main.c        **** //#define ENABLEREADFUSELOCK
 129:main.c        **** 
 130:main.c        **** /* enable/disable write of lock-bits
 131:main.c        ****  * WARNING: lock-bits can not be reseted by bootloader (as far as I know)
 132:main.c        ****  * Only protection no unprotection, "chip erase" from bootloader only
 133:main.c        ****  * clears the flash but does no real "chip erase" (this is not possible
 134:main.c        ****  * with a bootloader as far as I know)
 135:main.c        ****  * Keep this undefined!
 136:main.c        ****  */
 137:main.c        **** //#define WRITELOCKBITS
 138:main.c        **** 
 139:main.c        **** /*
 140:main.c        ****  * define the following if the bootloader should not output
 141:main.c        ****  * itself at flash read (will fake an empty boot-section)
 142:main.c        ****  */
 143:main.c        **** //#define READ_PROTECT_BOOTLOADER 
 144:main.c        **** 
 145:main.c        **** #define VERSION_HIGH '0'
 146:main.c        **** #define VERSION_LOW  '8'
 147:main.c        **** 
 148:main.c        **** #define GET_LOCK_BITS           0x0001
 149:main.c        **** #define GET_LOW_FUSE_BITS       0x0000
 150:main.c        **** #define GET_HIGH_FUSE_BITS      0x0003
 151:main.c        **** #define GET_EXTENDED_FUSE_BITS  0x0002
 152:main.c        **** 
 153:main.c        **** /* Расчет делителя частоты для USART*/
 154:main.c        **** #ifdef UART_DOUBLESPEED
 155:main.c        **** 
 156:main.c        **** 	#define UART_CALC_BAUDRATE(baudRate) ((uint32_t)((F_CPU) + ((uint32_t)baudRate * 4UL)) / ((uint32_
 157:main.c        **** 
 158:main.c        **** #else
 159:main.c        **** 
 160:main.c        **** 	#define UART_CALC_BAUDRATE(baudRate) ((uint32_t)((F_CPU) + ((uint32_t)baudRate * 8UL)) / ((uint32_
 161:main.c        **** 
 162:main.c        **** #endif
 163:main.c        **** 
 164:main.c        **** 
 165:main.c        **** #include <stdint.h>
 166:main.c        **** #include <avr/io.h>
 167:main.c        **** #include <avr/wdt.h>
 168:main.c        **** #include <avr/boot.h>
 169:main.c        **** #include <avr/pgmspace.h>
 170:main.c        **** #include <avr/eeprom.h>
 171:main.c        **** #include <avr/interrupt.h>
 172:main.c        **** #include <util/delay.h>
 173:main.c        **** 
 174:main.c        **** #include "chipdef.h"
 175:main.c        **** 
 176:main.c        **** uint8_t gBuffer[SPM_PAGESIZE];
 177:main.c        **** 
 178:main.c        **** #if defined(BOOTLOADERHASNOVECTORS)
 179:main.c        **** 	#warning "This Bootloader does not link interrupt vectors - see makefile"
 180:main.c        **** 	/* make the linker happy - it wants to see __vector_default */
 181:main.c        **** 	// void __vector_default(void) { ; }
 182:main.c        **** 	void __vector_default(void) { ; }
  97               	tabn	68,0,182,.LM0-.LFBB1
  98               	.LM0:
  99               	.LFBB1:
 100               	/* prologue: function */
 101               	/* frame size = 0 */
 102               	/* epilogue start */
 104               	.LM1:
 105 0000 0895      		ret
 107               	.Lscope1:
 109               	.global	main
 111               	main:
 183:main.c        **** T_STATUS & (1<<UART_TXREADY)));
 184:main.c        **** 	UART_DATA = data;
 185:main.c        **** }
 186:main.c        **** 
 187:main.c        **** static uint8_t recvchar(void)
 188:main.c        **** {
 189:main.c        **** 	while (!(UART_STATUS & (1<<UART_RXREADY)));
 190:main.c        **** 	return UART_DATA;
 191:main.c        **** }
 192:main.c        **** 
 193:main.c        **** static inline void eraseFlash(void)
 194:main.c        **** {
 195:main.c        **** 	// erase only main section (bootloader protection)
 196:main.c        **** 	uint32_t addr = 0;
 197:main.c        **** 	while (APP_END > addr) 
 198:main.c        **** 		{
 199:main.c        **** 		boot_page_erase(addr);		// Perform page erase
 200:main.c        **** 		boot_spm_busy_wait();		// Wait until the memory is erased.
 201:main.c        **** 		addr += SPM_PAGESIZE;
 202:main.c        **** 		}
 203:main.c        **** 	boot_rww_enable();
 204:main.c        **** }
 205:main.c        **** 
 206:main.c        **** static inline void recvBuffer(pagebuf_t size)
 207:main.c        **** {
 208:main.c        **** 	pagebuf_t cnt;
 209:main.c        **** 	uint8_t *tmp = gBuffer;
 210:main.c        **** 
 211:main.c        **** 	for (cnt = 0; cnt < sizeof(gBuffer); cnt++) 
 212:main.c        **** 		{
 213:main.c        **** 		*tmp++ = (cnt < size) ? recvchar() : 0xFF;
 214:main.c        **** 		}
 215:main.c        **** }
 216:main.c        **** 
 217:main.c        **** static inline uint16_t writeFlashPage(uint16_t waddr, pagebuf_t size)
 218:main.c        **** {
 219:main.c        **** 	uint32_t pagestart = (uint32_t)waddr<<1;
 220:main.c        **** 	uint32_t baddr = pagestart;
 221:main.c        **** 	uint16_t data;
 222:main.c        **** 	uint8_t *tmp = gBuffer;
 223:main.c        **** 
 224:main.c        **** 	do 
 225:main.c        **** 		{
 226:main.c        **** 		data = *tmp++;
 227:main.c        **** 		data |= *tmp++ << 8;
 228:main.c        **** 		boot_page_fill(baddr, data);	// call asm routine.
 229:main.c        **** 
 230:main.c        **** 		baddr += 2;			// Select next word in memory
 231:main.c        **** 		size -= 2;			// Reduce number of bytes to write by two
 232:main.c        **** 		} 
 233:main.c        **** 	while (size);				// Loop until all bytes written
 234:main.c        **** 
 235:main.c        **** 	boot_page_write(pagestart);
 236:main.c        **** 	boot_spm_busy_wait();
 237:main.c        **** 	boot_rww_enable();		// Re-enable the RWW section
 238:main.c        **** 
 239:main.c        **** 	return baddr>>1;
 240:main.c        **** }
 241:main.c        **** 
 242:main.c        **** static inline uint16_t writeEEpromPage(uint16_t address, pagebuf_t size)
 243:main.c        **** {
 244:main.c        **** 	uint8_t *tmp = gBuffer;
 245:main.c        **** 
 246:main.c        **** 	do 
 247:main.c        **** 		{
 248:main.c        **** 		eeprom_write_byte( (uint8_t*)address, *tmp++ );
 249:main.c        **** 		address++;			// Select next byte
 250:main.c        **** 		size--;				// Decreas number of bytes to write
 251:main.c        **** 		}
 252:main.c        **** 	while (size);				// Loop until all bytes written
 253:main.c        **** 
 254:main.c        **** 	// eeprom_busy_wait();
 255:main.c        **** 
 256:main.c        **** 	return address;
 257:main.c        **** }
 258:main.c        **** 
 259:main.c        **** static inline uint16_t readFlashPage(uint16_t waddr, pagebuf_t size)
 260:main.c        **** {
 261:main.c        **** 	uint32_t baddr = (uint32_t)waddr<<1;
 262:main.c        **** 	uint16_t data;
 263:main.c        **** 
 264:main.c        **** 	do 
 265:main.c        **** 	{
 266:main.c        **** 
 267:main.c        **** #ifndef READ_PROTECT_BOOTLOADER
 268:main.c        **** #warning "Bootloader not read-protected"
 269:main.c        **** 
 270:main.c        **** 	#if defined(RAMPZ)
 271:main.c        **** 		data = pgm_read_word_far(baddr);
 272:main.c        **** 	#else
 273:main.c        **** 		data = pgm_read_word_near(baddr);
 274:main.c        **** 	#endif
 275:main.c        **** 
 276:main.c        **** #else
 277:main.c        **** 		// don't read bootloader
 278:main.c        **** 		if ( baddr < APP_END ) 
 279:main.c        **** 		{
 280:main.c        **** 		#if defined(RAMPZ)
 281:main.c        **** 			data = pgm_read_word_far(baddr);
 282:main.c        **** 		#else
 283:main.c        **** 			data = pgm_read_word_near(baddr);
 284:main.c        **** 		#endif
 285:main.c        **** 		}
 286:main.c        **** 		else 
 287:main.c        **** 		{
 288:main.c        **** 		data = 0xFFFF; // fake empty
 289:main.c        **** 		}
 290:main.c        **** #endif
 291:main.c        **** 		sendchar(data);			// send LSB
 292:main.c        **** 		sendchar((data >> 8));		// send MSB
 293:main.c        **** 		baddr += 2;			// Select next word in memory
 294:main.c        **** 		size -= 2;			// Subtract two bytes from number of bytes to read
 295:main.c        **** 	} 
 296:main.c        **** 	while (size);				// Repeat until block has been read
 297:main.c        **** 	return baddr>>1;
 298:main.c        **** }
 299:main.c        **** 
 300:main.c        **** static inline uint16_t readEEpromPage(uint16_t address, pagebuf_t size)
 301:main.c        **** {
 302:main.c        **** 	do 
 303:main.c        **** 	{
 304:main.c        **** 	sendchar( eeprom_read_byte( (uint8_t*)address ) );
 305:main.c        **** 	address++;
 306:main.c        **** 	size--;				// Decrease number of bytes to read
 307:main.c        **** 	} 
 308:main.c        **** 	while (size);				// Repeat until block has been read
 309:main.c        **** 
 310:main.c        **** 	return address;
 311:main.c        **** }
 312:main.c        **** 
 313:main.c        **** #if defined(ENABLEREADFUSELOCK)
 314:main.c        **** static uint8_t read_fuse_lock(uint16_t addr)
 315:main.c        **** {
 316:main.c        **** 	uint8_t mode = (1<<BLBSET) | (1<<SPMEN);
 317:main.c        **** 	uint8_t retval;
 318:main.c        **** 
 319:main.c        **** 	asm volatile
 320:main.c        **** 	(
 321:main.c        **** 		"movw r30, %3\n\t"		/* Z to addr */ \
 322:main.c        **** 		"sts %0, %2\n\t"		/* set mode in SPM_REG */ \
 323:main.c        **** 		"lpm\n\t"			/* load fuse/lock value into r0 */ \
 324:main.c        **** 		"mov %1,r0\n\t"			/* save return value */ \
 325:main.c        **** 		: "=m" (SPM_REG),
 326:main.c        **** 		  "=r" (retval)
 327:main.c        **** 		: "r" (mode),
 328:main.c        **** 		  "r" (addr)
 329:main.c        **** 		: "r30", "r31", "r0"
 330:main.c        **** 	);
 331:main.c        **** 	return retval;
 332:main.c        **** }
 333:main.c        **** #endif
 334:main.c        **** 
 335:main.c        **** static void send_boot(void)
 336:main.c        **** {
 337:main.c        **** 	sendchar('A');
 338:main.c        **** 	sendchar('V');
 339:main.c        **** 	sendchar('R');
 340:main.c        **** 	sendchar('B');
 341:main.c        **** 	sendchar('O');
 342:main.c        **** 	sendchar('O');
 343:main.c        **** 	sendchar('T');
 344:main.c        **** }
 345:main.c        **** 
 346:main.c        **** static void (*jump_to_app)(void) = 0x0000;
 347:main.c        **** 
 348:main.c        **** int main(void)
 349:main.c        **** {
 350:main.c        **** 	uint16_t address = 0;
 351:main.c        **** 	uint8_t device = 0, val;
 352:main.c        **** 
 353:main.c        **** 
 112               	3,.LM2-.LFBB2
 113               	.LM2:
 114               	.LFBB2:
 115 0002 2F92      		push r2
 116 0004 3F92      		push r3
 117 0006 4F92      		push r4
 118 0008 5F92      		push r5
 119 000a 6F92      		push r6
 120 000c 7F92      		push r7
 121 000e 8F92      		push r8
 122 0010 9F92      		push r9
 123 0012 AF92      		push r10
 124 0014 BF92      		push r11
 125 0016 CF92      		push r12
 126 0018 DF92      		push r13
 127 001a EF92      		push r14
 128 001c FF92      		push r15
 129 001e 0F93      		push r16
 130 0020 1F93      		push r17
 131 0022 CF93      		push r28
 132 0024 DF93      		push r29
 133               	/* prologue: function */
 134               	/* frame size = 0 */
 354:main.c        **** 
 355:main.c        **** 		#warning "using target specific watchdog_off"
 356:main.c        **** 		bootloader_wdt_off();
 357:main.c        **** 	#else
 358:main.c        **** 		cli();
 359:main.c        **** 		wdt_reset();
 360:main.c        **** 		wdt_disable();
 135               	LFBB2
 136               	.LM3:
 137 0026 C09A      		sbi 56-32,0
 361:main.c        **** f
 138               	tabn	68,0,361,.LM4-.LFBB2
 139               	.LM4:
 140 0028 B89A      		sbi 55-32,0
 362:main.c        **** endif
 363:main.c        **** 	
 364:main.c        **** #ifdef START_POWERSAVE
 365:main.c        **** 	uint8_t OK = 1;
 366:main.c        **** #endif
 367:main.c        **** 
 368:main.c        **** 	BLDDR  &= ~(1<<BLPNUM);		// set as Input
 369:main.c        **** 	BLPORT |= (1<<BLPNUM);		// Enable pullup
 370:main.c        **** 
 141               	tabn	68,0,370,.LM5-.LFBB2
 142               	.LM5:
 143               	/* #APP */
 144               	 ;  370 "main.c" 1
 145 002a F894      		cli
 146               	 ;  0 "" 2
 371:main.c        **** aud rate
 147               	n	68,0,371,.LM6-.LFBB2
 148               	.LM6:
 149               	 ;  371 "main.c" 1
 150 002c A895      		wdr
 151               	 ;  0 "" 2
 372:main.c        **** UART_BAUD_HIGH = (UART_CALC_BAUDRATE(BAUDRATE)>>8) & 0xFF;
 152               	bn	68,0,372,.LM7-.LFBB2
 153               	.LM7:
 154               	/* #NOAPP */
 155 002e 98E1      		ldi r25,lo8(24)
 156               	/* #APP */
 157               	 ;  372 "main.c" 1
 158 0030 0FB6      		in __tmp_reg__, __SREG__
 159 0032 F894      		cli
 160 0034 91BD      		out 33, r25
 161 0036 11BC      		out 33, __zero_reg__
 162 0038 0FBE      		out __SREG__,__tmp_reg__
 163               		
 164               	 ;  0 "" 2
 373:main.c        **** UART_BAUD_LOW = (UART_CALC_BAUDRATE(BAUDRATE) & 0xFF);
 374:main.c        **** 
 375:main.c        **** #ifdef UART_DOUBLESPEED
 376:main.c        **** 	UART_STATUS = ( 1<<UART_DOUBLE );
 377:main.c        **** #endif
 378:main.c        **** 
 379:main.c        **** 	UART_CTRL = UART_CTRL_DATA;
 380:main.c        **** 	UART_CTRL2 = UART_CTRL2_DATA;
 165               	380,.LM8-.LFBB2
 166               	.LM8:
 167               	/* #NOAPP */
 168 003a B998      		cbi 55-32,1
 381:main.c        **** fined(START_POWERSAVE)
 169               	abn	68,0,381,.LM9-.LFBB2
 170               	.LM9:
 171 003c C19A      		sbi 56-32,1
 382:main.c        **** /*
 383:main.c        **** 		This is an adoption of the Butterfly Bootloader startup-sequence.
 384:main.c        **** 		It may look a little strange but separating the login-loop from
 172               	tabn	68,0,384,.LM10-.LFBB2
 173               	.LM10:
 174 003e 10BC      		out 64-32,__zero_reg__
 385:main.c        **** he main parser-loop gives a lot a possibilities (timeout, sleep-modes
 175               	tabn	68,0,385,.LM11-.LFBB2
 176               	.LM11:
 177 0040 8FE2      		ldi r24,lo8(47)
 178 0042 89B9      		out 41-32,r24
 386:main.c        ****     etc.).
 387:main.c        **** 	*/
 388:main.c        **** 	for(;OK;) 
 179               	abn	68,0,388,.LM12-.LFBB2
 180               	.LM12:
 181 0044 82E0      		ldi r24,lo8(2)
 182 0046 8BB9      		out 43-32,r24
 389:main.c        **** 
 390:main.c        **** 		if ((BLPIN & (1<<BLPNUM))) 
 391:main.c        **** 		{
 183               	abn	68,0,391,.LM13-.LFBB2
 184               	.LM13:
 185 0048 9AB9      		out 42-32,r25
 392:main.c        **** 	// jump to main app if pin is not grounded
 186               	tabn	68,0,392,.LM14-.LFBB2
 187               	.LM14:
 188 004a 86E8      		ldi r24,lo8(-122)
 189 004c 80BD      		out 64-32,r24
 393:main.c        **** 	BLPORT &= ~(1<<BLPNUM);	// set to default
 394:main.c        **** 
 395:main.c        **** 		#ifdef UART_DOUBLESPEED
 396:main.c        **** 			UART_STATUS &= ~( 1<<UART_DOUBLE );
 397:main.c        **** 		#endif
 398:main.c        **** 
 399:main.c        **** 
 400:main.c        **** 		#ifdef ENABLE_BOOT_LED	// LED OFF
 401:main.c        **** 		BIPORT &= ~(1<<BIPNUM);	
 402:main.c        **** 		BIDDR  &= ~(1<<BIPNUM);
 403:main.c        **** 		#endif
 404:main.c        **** 
 405:main.c        **** 		jump_to_app();		// Jump to application sector
 406:main.c        **** 
 407:main.c        **** 		} 
 408:main.c        **** 		else 
 409:main.c        **** 		{
 410:main.c        **** 		val = recvchar();
 411:main.c        **** 		/* ESC */
 412:main.c        **** 			if (val == 0x1B) 
 413:main.c        **** 			{
 414:main.c        **** 				// AVRPROG connection
 415:main.c        **** 				// Wait for signon
 416:main.c        **** 				while (val != 'S')
 417:main.c        **** 				val = recvchar();
 418:main.c        **** 				
 419:main.c        **** 				send_boot();			// Report signon
 420:main.c        **** 				OK = 0;
 421:main.c        **** 			} 
 422:main.c        **** 			else 
 423:main.c        **** 			{
 424:main.c        **** 			sendchar('?');
 425:main.c        **** 			}
 426:main.c        **** 	    }
 427:main.c        **** 		// Power-Save code here
 428:main.c        **** 	}
 429:main.c        **** 
 430:main.c        **** #elif defined(START_SIMPLE)
 431:main.c        **** 
 432:main.c        **** 	if ((BLPIN & (1<<BLPNUM))) {
 433:main.c        **** 		// jump to main app if pin is not grounded
 434:main.c        **** 		BLPORT &= ~(1<<BLPNUM);		// set to default	
 435:main.c        **** 			
 436:main.c        **** 	#ifdef UART_DOUBLESPEED
 437:main.c        **** 		UART_STATUS &= ~( 1<<UART_DOUBLE );
 438:main.c        **** 	#endif
 439:main.c        **** 
 440:main.c        **** 		#ifdef ENABLE_BOOT_LED	// LED OFF
 441:main.c        **** 		BIPORT &= ~(1<<BIPNUM);	
 442:main.c        **** 		BIDDR  &= ~(1<<BIPNUM);
 443:main.c        **** 		#endif
 444:main.c        **** 
 445:main.c        **** 		jump_to_app();			// Jump to application sector
 190               	abn	68,0,445,.LM15-.LFBB2
 191               	.LM15:
 192 004e B19B      		sbis 54-32,1
 193 0050 00C0      		rjmp .L4
 446:main.c        **** uint16_t cnt = 0;
 447:main.c        **** 
 194               	abn	68,0,447,.LM16-.LFBB2
 195               	.LM16:
 196 0052 C198      		cbi 56-32,1
 448:main.c        **** hile (1) {
 449:main.c        **** 		if (UART_STATUS & (1<<UART_RXREADY))
 450:main.c        **** 			if (UART_DATA == START_WAIT_UARTCHAR)
 197               	tabn	68,0,450,.LM17-.LFBB2
 198               	.LM17:
 199 0054 5998      		cbi 43-32,1
 451:main.c        **** 	break;
 452:main.c        **** 
 453:main.c        **** 		if (cnt++ >= WAIT_VALUE) {
 454:main.c        **** 			BLPORT &= ~(1<<BLPNUM);		// set to default
 200               	tabn	68,0,454,.LM18-.LFBB2
 201               	.LM18:
 202 0056 C098      		cbi 56-32,0
 455:main.c        **** 
 203               	tabn	68,0,455,.LM19-.LFBB2
 204               	.LM19:
 205 0058 B898      		cbi 55-32,0
 456:main.c        ****  & (1<<UART_RXREADY))
 457:main.c        **** 			if (UART_DATA == START_WAIT_UARTCHAR)
 458:main.c        **** 				break;
 206               	tabn	68,0,458,.LM20-.LFBB2
 207               	.LM20:
 208 005a E0E0      		ldi r30,lo8(0)
 209 005c F0E0      		ldi r31,hi8(0)
 210 005e 0995      		icall
 211               	.L4:
 212 0060 AA24      		clr r10
 213 0062 BB24      		clr r11
 214 0064 5524      		clr r5
 215               	.LBB130:
 216               	.LBB131:
 218               	.LM21:
 219 0066 B9E5      		ldi r27,lo8(89)
 220 0068 2B2E      		mov r2,r27
 221               	.LBE131:
 222               	.LBE130:
 223               	.LBB133:
 224               	.LBB134:
 225 006a ADE0      		ldi r26,lo8(13)
 226 006c CA2E      		mov r12,r26
 227               	.LBE134:
 228               	.LBE133:
 229               	.LBB136:
 230               	.LBB137:
 231               	.LBB138:
 233               	.LM22:
 234 006e F1E1      		ldi r31,lo8(17)
 235 0070 3F2E      		mov r3,r31
 236               	.LBE138:
 237               	.LBE137:
 238               	.LBE136:
 239               	.LBB158:
 240               	.LBB159:
 241               	.LBB160:
 242               	.LBB161:
 244               	.LM23:
 245 0072 EFE4      		ldi r30,lo8(79)
 246 0074 4E2E      		mov r4,r30
 247               	.L149:
 248               	.LBE161:
 249               	.LBE160:
 250               	.LBE159:
 251               	.LBE158:
 252               	.LBB177:
 253               	.LBB178:
 255               	.LM24:
 256 0076 5F9B      		sbis 43-32,7
 257 0078 00C0      		rjmp .L149
 259               	.LM25:
 260 007a 9CB1      		in r25,44-32
 261               	.LBE178:
 262               	.LBE177:
 459:main.c        **** if (cnt++ >= WAIT_VALUE) {
 460:main.c        **** 			BLPORT &= ~(1<<BLPNUM);		// set to default
 461:main.c        **** 
 462:main.c        **** 
 463:main.c        **** 			#ifdef ENABLE_BOOT_LED	// LED OFF
 464:main.c        **** 			BIPORT &= ~(1<<BIPNUM);	
 465:main.c        **** 			BIDDR  &= ~(1<<BIPNUM);
 466:main.c        **** 			#endif
 467:main.c        **** 			jump_to_app();			// Jump to application sector
 468:main.c        **** 		}
 469:main.c        **** 
 470:main.c        **** 		_delay_ms(10);
 471:main.c        **** 	}
 472:main.c        **** 	send_boot();
 473:main.c        **** 
 474:main.c        **** #elif defined(START_BOOTICE)
 475:main.c        **** #warning "BOOTICE mode - no startup-condition"
 476:main.c        **** 
 477:main.c        **** #else
 478:main.c        **** #error "Select START_ condition for bootloader in main.c"
 479:main.c        **** #endif
 480:main.c        **** 
 481:main.c        **** 
 482:main.c        **** 	for(;;) 
 483:main.c        **** 	{
 484:main.c        **** 		val = recvchar();
 485:main.c        **** 		// Autoincrement?
 486:main.c        **** 		if (val == 'a') 
 487:main.c        **** 		{
 488:main.c        **** 			sendchar('Y');			// Autoincrement is quicker
 489:main.c        **** 
 490:main.c        **** 		//write address
 491:main.c        **** 		} 
 492:main.c        **** 		else if (val == 'A') 
 493:main.c        **** 		{
 494:main.c        **** 			address = recvchar();		//read address 8 MSB
 495:main.c        **** 			address = (address<<8) | recvchar();
 496:main.c        **** 			sendchar('\r');
 497:main.c        **** 
 263               	ne .L6
 264               	.L79:
 265 007c 9136      	.LBB179:
 266 007e 01F4      	.LBB132:
 268               	.LM27:
 269               		sbis 43-32,5
 270               		rjmp .L79
 272 0080 5D9B      	.LM28:
 273 0082 00C0      		out 44-32,r2
 274               		rjmp .L149
 275               	.L6:
 276 0084 2CB8      	.LBE132:
 277 0086 00C0      	.LBE179:
 279               	.LM29:
 280               		cpi r25,lo8(65)
 498:main.c        ****  
 499:main.c        **** 		else if (val == 'b') 
 500:main.c        **** 		{
 501:main.c        **** 			sendchar('Y');					// Report buffer load supported
 502:main.c        **** 			sendchar((sizeof(gBuffer) >> 8) & 0xFF);	// Report buffer size in bytes
 503:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 281               	BB180:
 282               	.LBB181:
 284 008a 01F4      	.LM30:
 285               		sbis 43-32,7
 286               		rjmp .L80
 288               	.LM31:
 289               		in r25,44-32
 290 008c 5F9B      	.L10:
 291 008e 00C0      	.LBE181:
 292               	.LBE180:
 293               	.LBB182:
 294 0090 9CB1      	.LBB183:
 296               	.LM32:
 297               		sbis 43-32,7
 298               		rjmp .L10
 300               	.LM33:
 301               		in r24,44-32
 302 0092 5F9B      	.L11:
 303 0094 00C0      	.LBE183:
 304               	.LBE182:
 305               	.LBB184:
 306 0096 8CB1      	.LBB135:
 308               	.LM34:
 309               		sbis 43-32,5
 310               		rjmp .L11
 311               	.LBE135:
 312               	.LBE184:
 314 0098 5D9B      	.LM35:
 315 009a 00C0      		mov r7,r25
 316               		clr r6
 317               		mov r10,r24
 504:main.c        ****  supported
 505:main.c        **** 			sendchar((sizeof(gBuffer) >> 8) & 0xFF);	// Report buffer size in bytes
 506:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 318               	.L155
 319               	.L8:
 321 009e 6624      	.LM36:
 322 00a0 A82E      		cpi r25,lo8(98)
 323 00a2 BB24      		brne .L12
 324 00a4 A628      	.L81:
 325 00a6 B728      	.LBB185:
 326 00a8 00C0      	.LBB186:
 507:main.c        ****  supported
 508:main.c        **** 			sendchar((sizeof(gBuffer) >> 8) & 0xFF);	// Report buffer size in bytes
 509:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 510:main.c        **** 
 511:main.c        **** 		// Start buffer load
 328               	is 43-32,5
 329               		rjmp .L81
 331 00ac 01F4      	.LM38:
 332               		out 44-32,r2
 333               	.L14:
 334               	.LBE186:
 335               	.LBE185:
 336               	.LBB187:
 337 00ae 5D9B      	.LBB188:
 339               	.LM39:
 340               		sbis 43-32,5
 341 00b2 2CB8      		rjmp .L14
 343               	.LM40:
 344               		out 44-32,__zero_reg__
 345               	.L15:
 346               	.LBE188:
 347               	.LBE187:
 348               	.LBB189:
 349 00b4 5D9B      	.LBB190:
 351               	.LM41:
 352               		sbis 43-32,5
 353 00b8 1CB8      		rjmp .L15
 355               	.LM42:
 356               		ldi r18,lo8(64)
 357               		rjmp .L152
 358               	.L12:
 359               	.LBE190:
 360               	.LBE189:
 362 00bc 00C0      	.LM43:
 363               		cpi r25,lo8(66)
 364               		breq .+2
 365 00be 20E4      		rjmp .L16
 366 00c0 00C0      	.L85:
 367               	.LBB191:
 368               	.LBB141:
 369               	.LBB142:
 512:main.c        **** zeof(gBuffer) >> 8) & 0xFF);	// Report buffer size in bytes
 513:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 514:main.c        **** 
 515:main.c        **** 		// Start buffer load
 516:main.c        **** 		} 
 517:main.c        **** 		else if (val == 'B') 
 518:main.c        **** 		{
 519:main.c        **** 			pagebuf_t size;
 370               	 43-32,7
 371               		rjmp .L85
 373 00c4 01F0      	.LM45:
 374 00c6 00C0      		in r24,44-32
 375               	.L18:
 376               	.LBE142:
 377               	.LBE141:
 378               	.LBB143:
 379               	.LBB144:
 381 00c8 5F9B      	.LM46:
 382 00ca 00C0      		sbis 43-32,7
 383               		rjmp .L18
 385 00cc 8CB1      	.LM47:
 386               		in r13,44-32
 387               	.L19:
 388               	.LBE144:
 389               	.LBE143:
 390               	.LBB145:
 391               	.LBB146:
 393 00ce 5F9B      	.LM48:
 394 00d0 00C0      		sbis 43-32,7
 395               		rjmp .L19
 397 00d2 DCB0      	.LM49:
 398               		in r18,44-32
 399               		ldi r25,lo8(0)
 400               		ldi r30,lo8(gBuffer)
 401               		ldi r31,hi8(gBuffer)
 402               	.L23:
 403               	.LBE146:
 404               	.LBE145:
 405 00d4 5F9B      	.LBB147:
 406 00d6 00C0      	.LBB148:
 408               	.LM50:
 409 00d8 2CB1      		cp r25,r13
 410 00da 90E0      		brlo .L84
 411 00dc E0E0      		ldi r24,lo8(-1)
 412 00de F0E0      		rjmp .L21
 413               	.L84:
 414               	.LBB149:
 415               	.LBB150:
 417               	.LM51:
 418               		sbis 43-32,7
 419               		rjmp .L84
 421 00e2 00F0      	.LM52:
 422 00e4 8FEF      		in r24,44-32
 423 00e6 00C0      	.L21:
 424               	.LBE150:
 425               	.LBE149:
 427               	.LM53:
 428               		st Z,r24
 430 00ea 00C0      	.LM54:
 431               		subi r25,lo8(-(1))
 432               		cpi r25,lo8(64)
 433 00ec 8CB1      		breq .L22
 435               	.LM55:
 436               		adiw r30,1
 437               		rjmp .L23
 438               	.L22:
 439 00ee 8083      	.LBE148:
 440               	.LBE147:
 442 00f0 9F5F      	.LM56:
 443 00f2 9034      		ldi r22,lo8(119)
 444 00f4 01F0      		cp r5,r22
 445               		breq .+2
 446               		rjmp .L83
 448 00f8 00C0      	.LM57:
 449               		cpi r18,lo8(70)
 450               		breq .+2
 451               		rjmp .L25
 520:main.c        **** tes
 521:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 522:main.c        **** 
 523:main.c        **** 		// Start buffer load
 524:main.c        **** 		} 
 525:main.c        **** 		else if (val == 'B') 
 526:main.c        **** 		{
 527:main.c        **** 			pagebuf_t size;
 452               	0)
 453               		ldi r17,hi8(0)
 454 00fa 67E7      		lsl r14
 455 00fc 5616      		rol r15
 456 00fe 01F0      		rol r16
 457 0100 00C0      		rol r17
 528:main.c        **** tes
 529:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 458               	r20,r16
 459               		movw r18,r14
 460 0102 2634      		ldi r26,lo8(gBuffer)
 461 0104 01F0      		ldi r27,hi8(gBuffer)
 462 0106 00C0      	.L26:
 464               	.LM59:
 465               		ld r24,X
 466               		ldi r25,lo8(0)
 468 010a 00E0      	.LM60:
 469 010c 10E0      		adiw r26,1
 470 010e EE0C      		ld r9,X
 471 0110 FF1C      		sbiw r26,1
 472 0112 001F      		clr r8
 473 0114 111F      		or r24,r8
 474 0116 A801      		or r25,r9
 476 011a A0E0      	.LM61:
 477 011c B0E0      		adiw r26,2
 479               	.LM62:
 480               		ldi r22,lo8(1)
 481 011e 8C91      		movw r30,r18
 482 0120 90E0      	/* #APP */
 483               	 ;  232 "main.c" 1
 484               		movw  r0, r24
 485 0122 1196      		sts 87, r22
 486 0124 9C90      		spm
 487 0126 1197      		clr  r1
 488 0128 8824      		
 489 012a 8829      	 ;  0 "" 2
 491               	.LM63:
 492               	/* #NOAPP */
 493 012e 1296      		subi r18,lo8(-(2))
 494               		sbci r19,hi8(-(2))
 495               		sbci r20,hlo8(-(2))
 496 0130 61E0      		sbci r21,hhi8(-(2))
 498               	.LM64:
 499               		ldi r24,lo8(-2)
 500 0134 0C01      		add r13,r24
 502 013a E895      	.LM65:
 503 013c 1124      		brne .L26
 505               	.LM66:
 506               		ldi r22,lo8(5)
 507               		movw r30,r14
 508               	/* #APP */
 509 013e 2E5F      	 ;  239 "main.c" 1
 510 0140 3F4F      		sts 87, r22
 511 0142 4F4F      		spm
 512 0144 5F4F      		
 513               	 ;  0 "" 2
 514               	/* #NOAPP */
 515 0146 8EEF      	.L27:
 516 0148 D80E      	.LBE139:
 518               	.LM67:
 519 014a 01F4      		in __tmp_reg__,87-32
 520               		sbrc __tmp_reg__,0
 521               		rjmp .L27
 522 014c 65E0      	.LBB140:
 524               	.LM68:
 525               	/* #APP */
 526 0150 6093 5700 	 ;  241 "main.c" 1
 527 0154 E895      		sts 87, r3
 528               		spm
 529               		
 530               	 ;  0 "" 2
 532               	.LM69:
 533               	/* #NOAPP */
 534               		lsr r21
 535 0156 07B6      		ror r20
 536 0158 00FC      		ror r19
 537 015a 00C0      		ror r18
 538               		movw r10,r18
 539               		rjmp .L82
 540               	.L25:
 541               	.LBE140:
 542               	.LBE151:
 544 0160 E895      	.LM70:
 545               		cpi r18,lo8(69)
 546               		brne .L82
 547               		mov r15,r13
 548               		movw r16,r10
 549               		ldi r28,lo8(gBuffer)
 550 0162 5695      		ldi r29,hi8(gBuffer)
 551 0164 4795      	.L29:
 552 0166 3795      	.LBB152:
 553 0168 2795      	.LBB153:
 555 016c 00C0      	.LM71:
 556               		ld r22,Y+
 557               		movw r24,r16
 558               		rcall __eewr_byte_m8
 530:main.c        ****  supported
 531:main.c        **** 			sendchar((sizeof(gBuffer) >> 8) & 0xFF);	// Report buffer size in bytes
 532:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 533:main.c        **** 
 559               	LFBB2
 560               	.LM73:
 561 016e 2534      		dec r15
 563 0172 FD2C      	.LM74:
 564 0174 8501      		brne .L29
 565 0176 C0E0      		dec r13
 566 0178 D0E0      		mov r24,r13
 567               		ldi r25,lo8(0)
 568               		adiw r24,1
 569               		add r10,r24
 570               		adc r11,r25
 571               	.L82:
 572 017a 6991      	.LBE153:
 573 017c C801      	.LBE152:
 574 017e 00D0      	.LBB154:
 575               	.LBB155:
 577 0180 0F5F      	.LM75:
 578 0182 1F4F      		sbis 43-32,5
 579               		rjmp .L82
 580               		rjmp .L155
 581 0184 FA94      	.L83:
 582               	.LBE155:
 583               	.LBE154:
 584 0186 01F4      	.LBB156:
 585 0188 DA94      	.LBB157:
 586 018a 8D2D      		sbis 43-32,5
 587 018c 90E0      		rjmp .L83
 588 018e 0196      		rjmp .L154
 589 0190 A80E      	.L16:
 590 0192 B91E      	.LBE157:
 591               	.LBE156:
 592               	.LBE191:
 594               	.LM76:
 595               		cpi r25,lo8(103)
 596               		breq .+2
 597               		rjmp .L30
 598 0194 5D9B      	.L86:
 599 0196 00C0      	.LBB192:
 600 0198 00C0      	.LBB193:
 601               	.LBB194:
 603               	.LM77:
 604               		sbis 43-32,7
 605               		rjmp .L86
 607 019c 00C0      	.LM78:
 608 019e 00C0      		in r24,44-32
 609               	.L32:
 610               	.LBE194:
 611               	.LBE193:
 612               	.LBB195:
 534:main.c        **** upported
 535:main.c        **** 			sendchar((sizeof(gBuffer) >> 8) & 0xFF);	// Report buffer size in bytes
 536:main.c        **** 			sendchar(sizeof(gBuffer) & 0xFF);
 537:main.c        **** 
 538:main.c        **** 		// Start buffer load
 539:main.c        **** 		} 
 540:main.c        **** 		else if (val == 'B') 
 541:main.c        **** 		{
 542:main.c        **** 			pagebuf_t size;
 543:main.c        **** 			size = recvchar() << 8;				// Load high byte of buffersize
 544:main.c        **** 			size |= recvchar();				// Load low byte of buffersize
 545:main.c        **** 			val = recvchar();				// Load memory type ('E' or 'F')
 546:main.c        **** 			recvBuffer(size);
 613               	-32,7
 614               		rjmp .L32
 616 01a2 01F0      	.LM80:
 617 01a4 00C0      		in r15,44-32
 618               	.L33:
 619               	.LBE196:
 620               	.LBE195:
 621               	.LBB197:
 622               	.LBB198:
 624 01a6 5F9B      	.LM81:
 625 01a8 00C0      		sbis 43-32,7
 626               		rjmp .L33
 628 01aa 8CB1      	.LM82:
 629               		in r24,44-32
 630               	.LBE198:
 631               	.LBE197:
 633               	.LM83:
 634               		cpi r24,lo8(70)
 635               		brne .L34
 636 01ac 5F9B      	.LBB199:
 637 01ae 00C0      	.LBB200:
 639               	.LM84:
 640 01b0 FCB0      		movw r24,r10
 641               		ldi r26,lo8(0)
 642               		ldi r27,hi8(0)
 643               		lsl r24
 644               		rol r25
 645               		rol r26
 646               		rol r27
 647               	.L37:
 648 01b2 5F9B      	.LBB201:
 650               	.LM85:
 651               		movw r30,r24
 652 01b6 8CB1      	/* #APP */
 653               	 ;  277 "main.c" 1
 654               		lpm r18, Z+
 547:main.c        **** );				// Load low byte of buffersize
 548:main.c        **** 			val = recvchar();				// Load memory type ('E' or 'F')
 549:main.c        **** 			recvBuffer(size);
 550:main.c        **** 
 551:main.c        **** 			if (device == DEVTYPE) 
 552:main.c        **** 			{
 553:main.c        **** 				if (val == 'F') 
 655               	:
 656               	.LBE201:
 657 01b8 8634      	.LBB202:
 658 01ba 01F4      	.LBB203:
 660               	.LM86:
 661               		sbis 43-32,5
 662               		rjmp .L35
 664 01be A0E0      	.LM87:
 665 01c0 B0E0      		out 44-32,r18
 666 01c2 880F      	.L36:
 667 01c4 991F      	.LBE203:
 668 01c6 AA1F      	.LBE202:
 669 01c8 BB1F      	.LBB204:
 670               	.LBB205:
 672               	.LM88:
 673               		sbis 43-32,5
 674 01ca FC01      		rjmp .L36
 676               	.LM89:
 677 01cc 2591      		out 44-32,r19
 678 01ce 3491      	.LBE205:
 679               	.LBE204:
 681               	.LM90:
 682               		adiw r24,2
 683               		adc r26,__zero_reg__
 684               		adc r27,__zero_reg__
 686               	.LM91:
 687               		ldi r30,lo8(-2)
 688 01d0 5D9B      		add r15,r30
 690               	.LM92:
 691               		brne .L37
 693               	.LM93:
 694               		lsr r27
 695               		ror r26
 696               		ror r25
 697               		ror r24
 698               		movw r10,r24
 699               		rjmp .L149
 700 01d6 5D9B      	.L34:
 701 01d8 00C0      	.LBE200:
 702               	.LBE199:
 704 01da 3CB9      	.LM94:
 705               		cpi r24,lo8(69)
 706               		breq .+2
 707               		rjmp .L149
 708               		mov r14,r15
 709 01dc 0296      		movw r16,r10
 710 01de A11D      	.L39:
 711 01e0 B11D      	.LBB206:
 713               	.LM95:
 714 01e2 EEEF      		movw r24,r16
 715 01e4 FE0E      		rcall __eerd_byte_m8
 716               	.L38:
 717               	.LBB207:
 718 01e6 01F4      	.LBB208:
 719               	.LBB209:
 721 01e8 B695      	.LM96:
 722 01ea A795      		sbis 43-32,5
 723 01ec 9795      		rjmp .L38
 725 01f0 5C01      	.LM97:
 726 01f2 00C0      		out 44-32,r24
 727               	.LBE209:
 728               	.LBE208:
 554:main.c        **** 			// Load memory type ('E' or 'F')
 555:main.c        **** 			recvBuffer(size);
 556:main.c        **** 
 557:main.c        **** 			if (device == DEVTYPE) 
 730               	2
 731               	.LM99:
 732 01f4 8534      		dec r14
 734 01f8 00C0      	.LM100:
 735 01fa EF2C      		brne .L39
 736 01fc 8501      		dec r15
 737               		mov r24,r15
 738               		ldi r25,lo8(0)
 739               		adiw r24,1
 740               		add r10,r24
 741 01fe C801      		adc r11,r25
 742 0200 00D0      		rjmp .L149
 743               	.L30:
 744               	.LBE207:
 745               	.LBE206:
 746               	.LBE192:
 748               	.LM101:
 749 0202 5D9B      		cpi r25,lo8(101)
 750 0204 00C0      		brne .L40
 752               	.LM102:
 753 0206 8CB9      		ldi r31,lo8(119)
 754               		cp r5,r31
 755               		brne .L87
 756               		ldi r30,lo8(0)
 757               		ldi r31,hi8(0)
 758 0208 0F5F      	.L43:
 759 020a 1F4F      	.LBB210:
 760               	.LBB211:
 762 020c EA94      	.LM103:
 763               		ldi r18,lo8(3)
 764               	/* #APP */
 765 020e 01F4      	 ;  203 "main.c" 1
 766 0210 FA94      		sts 87, r18
 767 0212 8F2D      		spm
 768 0214 90E0      		
 769 0216 0196      	 ;  0 "" 2
 770 0218 A80E      	/* #NOAPP */
 771 021a B91E      	.L42:
 772 021c 00C0      	.LBE211:
 774               	.LM104:
 775               		in __tmp_reg__,87-32
 776               		sbrc __tmp_reg__,0
 558:main.c        **** ersize
 559:main.c        **** 			val = recvchar();				// Load memory type ('E' or 'F')
 560:main.c        **** 			recvBuffer(size);
 561:main.c        **** 
 562:main.c        **** 			if (device == DEVTYPE) 
 563:main.c        **** 			{
 564:main.c        **** 				if (val == 'F') 
 777               	(64))
 778               	.LBB212:
 780 0220 01F4      	.LM105:
 565:main.c        **** 			// Load memory type ('E' or 'F')
 566:main.c        **** 			recvBuffer(size);
 781               	 r22,hi8(6144)
 782               		cpi r30,lo8(6144)
 783 0222 F7E7      		cpc r31,r22
 784 0224 5F16      		brne .L43
 786 0228 E0E0      	.LM106:
 787 022a F0E0      	/* #APP */
 788               	 ;  207 "main.c" 1
 789               		sts 87, r3
 790               		spm
 791               		
 792               	 ;  0 "" 2
 793 022c 23E0      	/* #NOAPP */
 794               	.L87:
 795               	.LBE212:
 796 022e 2093 5700 	.LBE210:
 797 0232 E895      	.LBB213:
 798               	.LBB214:
 800               	.LM107:
 801               		sbis 43-32,5
 802               		rjmp .L87
 803               		rjmp .L155
 804               	.L40:
 805 0234 07B6      	.LBE214:
 806 0236 00FC      	.LBE213:
 808 023a E05C      	.LM108:
 809 023c FF4F      		cpi r25,lo8(69)
 810               		brne .L44
 812               	.LM109:
 813 023e 68E1      		ldi r18,lo8(12)
 814 0240 E030      		ldi r24,lo8(24)
 815 0242 F607      		ldi r25,hi8(24)
 816 0244 01F4      	/* #APP */
 817               	 ;  576 "main.c" 1
 818               		in __tmp_reg__,__SREG__
 819               		cli
 820               		wdr
 821 0246 3092 5700 		out 33,r24
 822 024a E895      		out __SREG__,__tmp_reg__
 823               		out 33,r18
 824               	 ;  0 "" 2
 825               	/* #NOAPP */
 826               	.L45:
 827               	.LBB215:
 828               	.LBB216:
 830               	.LM110:
 831               		sbis 43-32,5
 832               		rjmp .L45
 833 024c 5D9B      		rjmp .L155
 834 024e 00C0      	.L44:
 835 0250 00C0      	.LBE216:
 836               	.LBE215:
 838               	.LM111:
 567:main.c        **** );				// Load low byte of buffersize
 568:main.c        **** 			val = recvchar();				// Load memory type ('E' or 'F')
 569:main.c        **** 			recvBuffer(size);
 570:main.c        **** 
 571:main.c        **** 			if (device == DEVTYPE) 
 572:main.c        **** 			{
 573:main.c        **** 				if (val == 'F') 
 574:main.c        **** 				{
 839               	n	68,0,187,.LM112-.LFBB2
 840               	.LM112:
 841 0252 9534      		sbis 43-32,5
 842 0254 01F4      		rjmp .L88
 575:main.c        **** oad memory type ('E' or 'F')
 576:main.c        **** 			recvBuffer(size);
 843               	p .L155
 844               	.L46:
 845 0256 2CE0      	.LBE218:
 846 0258 88E1      	.LBE217:
 848               	.LM113:
 849               		cpi r25,lo8(76)
 850 025c 0FB6      		brne .L48
 851 025e F894      	.L89:
 852 0260 A895      	.LBB219:
 853 0262 81BD      	.LBB220:
 855 0266 21BD      	.LM114:
 856               		sbis 43-32,5
 857               		rjmp .L89
 858               		rjmp .L155
 859               	.L48:
 860               	.LBE220:
 861               	.LBE219:
 863 0268 5D9B      	.LM115:
 864 026a 00C0      		cpi r25,lo8(112)
 865 026c 00C0      		brne .L50
 866               	.L90:
 867               	.LBB221:
 868               	.LBB222:
 577:main.c        **** );				// Load low byte of buffersize
 578:main.c        **** 			val = recvchar();				// Load memory type ('E' or 'F')
 579:main.c        **** 			recvBuffer(size);
 580:main.c        **** 
 581:main.c        **** 			if (device == DEVTYPE) 
 582:main.c        **** 			{
 583:main.c        **** 				if (val == 'F') 
 584:main.c        **** 				{
 585:main.c        **** 				address = writeFlashPage(address, size);
 586:main.c        **** 				} 
 587:main.c        **** 				else if (val == 'E') 
 588:main.c        **** 				{
 589:main.c        **** 				address = writeEEpromPage(address, size);
 590:main.c        **** 				}
 591:main.c        **** 				sendchar('\r');
 592:main.c        **** 			} 
 593:main.c        **** 			else 
 594:main.c        **** 			{
 595:main.c        **** 			sendchar(0);
 596:main.c        **** 			}
 869               	FBB2
 870               	.LM116:
 871 026e 9035      		sbis 43-32,5
 872 0270 01F4      		rjmp .L90
 874               	.LM117:
 875               		ldi r24,lo8(83)
 876               		rjmp .L150
 877               	.L50:
 878 0272 5D9B      	.LBE222:
 879 0274 00C0      	.LBE221:
 881               	.LM118:
 882               		cpi r25,lo8(116)
 883               		brne .L52
 597:main.c        ****  = writeEEpromPage(address, size);
 598:main.c        **** 				}
 599:main.c        **** 				sendchar('\r');
 600:main.c        **** 			} 
 601:main.c        **** 			else 
 602:main.c        **** 			{
 884               	.LBB224:
 886 0278 9C34      	.LM119:
 887 027a 01F4      		sbis 43-32,5
 888               		rjmp .L91
 890               	.LM120:
 891               		ldi r30,lo8(119)
 892               		out 44-32,r30
 893 027c 5D9B      	.L54:
 894 027e 00C0      	.LBE224:
 895 0280 00C0      	.LBE223:
 896               	.LBB225:
 897               	.LBB226:
 603:main.c        **** E') 
 604:main.c        **** 				{
 605:main.c        **** 				address = writeEEpromPage(address, size);
 606:main.c        **** 				}
 607:main.c        **** 				sendchar('\r');
 899               	3-32,5
 900               		rjmp .L54
 901 0282 9037      	.L154:
 903               	.LM122:
 904               		out 44-32,__zero_reg__
 905               		rjmp .L149
 906               	.L52:
 907               	.LBE226:
 908 0286 5D9B      	.LBE225:
 910               	.LM123:
 911               		mov r24,r25
 912 028a 83E5      		subi r24,lo8(-(-120))
 913 028c 00C0      		cpi r24,lo8(2)
 914               		brsh .L55
 915               	.L92:
 916               	.LBB227:
 608:main.c        **** 
 609:main.c        **** 				else if (val == 'E') 
 610:main.c        **** 				{
 611:main.c        **** 				address = writeEEpromPage(address, size);
 612:main.c        **** 				}
 613:main.c        **** 				sendchar('\r');
 614:main.c        **** 			} 
 615:main.c        **** 			else 
 616:main.c        **** 			{
 617:main.c        **** 			sendchar(0);
 618:main.c        **** 			}
 619:main.c        **** 
 620:main.c        **** 		// Block read
 621:main.c        **** 		} 
 622:main.c        **** 		else if (val == 'g') 
 623:main.c        **** 		{
 624:main.c        **** 			pagebuf_t size;
 625:main.c        **** 			size = recvchar() << 8;				// Load high byte of buffersize
 626:main.c        **** 			size |= recvchar();				// Load low byte of buffersize
 627:main.c        **** 			val = recvchar();				// Get memtype
 628:main.c        **** 
 629:main.c        **** 			if (val == 'F') 
 630:main.c        **** 			{
 631:main.c        **** 			address = readFlashPage(address, size);
 632:main.c        **** 			} 
 633:main.c        **** 			else if (val == 'E') 
 634:main.c        **** 			{
 635:main.c        **** 			address = readEEpromPage(address, size);
 636:main.c        **** 			}
 637:main.c        **** 
 638:main.c        **** 		// Chip erase
 639:main.c        ****  		} 
 917               	8,0,193,.LM124-.LFBB2
 918               	.LM124:
 919 028e 9437      		sbis 43-32,7
 920 0290 01F4      		rjmp .L92
 922               	.LM125:
 923               		in r24,44-32
 924               	.L57:
 925               	.LBE228:
 926 0292 5D9B      	.LBE227:
 927 0294 00C0      	.LBB229:
 928               	.LBB230:
 930 0296 E7E7      	.LM126:
 931 0298 ECB9      		sbis 43-32,5
 932               		rjmp .L57
 933               		rjmp .L155
 934               	.L55:
 935               	.LBE230:
 936               	.LBE229:
 938               	.LM127:
 939 029a 5D9B      		cpi r25,lo8(84)
 940 029c 00C0      		brne .L58
 941               	.L93:
 942               	.LBB231:
 943               	.LBB232:
 945 02a0 00C0      	.LM128:
 946               		sbis 43-32,7
 947               		rjmp .L93
 640:main.c        ****  == 'E') 
 641:main.c        **** 			{
 642:main.c        **** 			address = readEEpromPage(address, size);
 643:main.c        **** 			}
 644:main.c        **** 
 645:main.c        **** 		// Chip erase
 949               	32:
 950               	.LBE231:
 951 02a2 892F      	.LBB233:
 952 02a4 8857      	.LBB234:
 954 02a8 00F4      	.LM130:
 955               		sbis 43-32,5
 956               		rjmp .L60
 957               	.L155:
 959               	.LM131:
 960 02aa 5F9B      		out 44-32,r12
 961 02ac 00C0      		rjmp .L149
 962               	.L58:
 963               	.LBE234:
 964 02ae 8CB1      	.LBE233:
 966               	.LM132:
 967               		cpi r25,lo8(83)
 968               		brne .L61
 969               	.L94:
 970               	.LBB235:
 971               	.LBB176:
 972 02b0 5D9B      	.LBB163:
 973 02b2 00C0      	.LBB164:
 975               	.LM133:
 976               		sbis 43-32,5
 977               		rjmp .L94
 646:main.c        **** if (val == 'E') 
 647:main.c        **** 			{
 648:main.c        **** 			address = readEEpromPage(address, size);
 649:main.c        **** 			}
 650:main.c        **** 
 651:main.c        **** 		// Chip erase
 652:main.c        ****  		} 
 978               	2
 979               	.LM134:
 980 02b6 9435      		ldi r31,lo8(65)
 981 02b8 01F4      		out 44-32,r31
 982               	.L63:
 983               	.LBE164:
 984               	.LBE163:
 985               	.LBB165:
 986               	.LBB166:
 988 02bc 00C0      	.LM135:
 989               		sbis 43-32,5
 990               		rjmp .L63
 992               	.LM136:
 993               		ldi r18,lo8(86)
 994               		out 44-32,r18
 995               	.L64:
 996               	.LBE166:
 997               	.LBE165:
 998               	.LBB167:
 999 02c0 5D9B      	.LBB168:
 1001               	.LM137:
 1002               		sbis 43-32,5
 1003               		rjmp .L64
 1005 02c6 00C0      	.LM138:
 1006               		ldi r22,lo8(82)
 1007               		out 44-32,r22
 1008               	.L65:
 653:main.c        ****  == 'E') 
 654:main.c        **** 			{
 655:main.c        **** 			address = readEEpromPage(address, size);
 656:main.c        **** 			}
 657:main.c        **** 
 658:main.c        **** 		// Chip erase
 1009               	86)
 1010               		out 44-32,r18
 1011 02c8 9335      	.L64:
 1012 02ca 01F4      	.LBE166:
 1013               	.LBE165:
 1014               	.LBB167:
 1015               	.LBB168:
 1017               	.LM137:
 1018               		sbis 43-32,5
 1019               		rjmp .L64
 1021 02ce 00C0      	.LM138:
 1022               		ldi r22,lo8(82)
 1023               		out 44-32,r22
 1024 02d0 F1E4      	.L65:
 1025 02d2 FCB9      	.LBE168:
 1026               	.LBE167:
 1027               	.LBB169:
 1028               	.LBB170:
 1030               	.LM139:
 1031               		sbis 43-32,5
 1032               		rjmp .L65
 1034 02d6 00C0      	.LM140:
 1035               		ldi r24,lo8(66)
 1036               		out 44-32,r24
 1037 02d8 26E5      	.L66:
 1038 02da 2CB9      	.LBE170:
 1039               	.LBE169:
 1040               	.LBB171:
 1041               	.LBB162:
 1043               	.LM141:
 1044               		sbis 43-32,5
 1045               		rjmp .L66
 1047 02de 00C0      	.LM142:
 1048               		out 44-32,r4
 1049               	.L67:
 1050 02e0 62E5      	.LBE162:
 1051 02e2 6CB9      	.LBE171:
 1052               	.LBB172:
 1053               	.LBB173:
 1055               	.LM143:
 1056               		sbis 43-32,5
 1057               		rjmp .L67
 1059 02e4 5D9B      	.LM144:
 1060 02e6 00C0      		out 44-32,r4
 1061               	.L68:
 1062               	.LBE173:
 1063 02e8 82E4      	.LBE172:
 1064 02ea 8CB9      	.LBB174:
 1065               	.LBB175:
 1067               	.LM145:
 1068               		sbis 43-32,5
 1069               		rjmp .L68
 1071               	.LM146:
 1072 02ec 5D9B      		ldi r30,lo8(84)
 1073 02ee 00C0      		out 44-32,r30
 1074               		rjmp .L149
 1075               	.L61:
 1076 02f0 4CB8      	.LBE175:
 1077               	.LBE174:
 1078               	.LBE176:
 1079               	.LBE235:
 1081               	.LM147:
 1082               		cpi r25,lo8(86)
 1083               		brne .L69
 1084 02f2 5D9B      	.L95:
 1085 02f4 00C0      	.LBB236:
 1086               	.LBB237:
 1088 02f6 4CB8      	.LM148:
 1089               		sbis 43-32,5
 1090               		rjmp .L95
 1092               	.LM149:
 1093               		ldi r31,lo8(48)
 1094               		out 44-32,r31
 1095               	.L71:
 1096 02f8 5D9B      	.LBE237:
 1097 02fa 00C0      	.LBE236:
 1098               	.LBB238:
 1099               	.LBB239:
 1101 02fe ECB9      	.LM150:
 1102 0300 00C0      		sbis 43-32,5
 1103               		rjmp .L71
 1105               	.LM151:
 1106               		ldi r18,lo8(56)
 1107               	.L152:
 659:main.c        **** if (val == 'E') 
 660:main.c        **** 			{
 661:main.c        **** 			address = readEEpromPage(address, size);
 662:main.c        **** 			}
 663:main.c        **** 
 664:main.c        **** 		// Chip erase
 1108               	68,0,187,.LM150-.LFBB2
 1109               	.LM150:
 1110 0302 9635      		sbis 43-32,5
 1111 0304 01F4      		rjmp .L71
 1113               	.LM151:
 1114               		ldi r18,lo8(56)
 1115               	.L152:
 1116               		out 44-32,r18
 1117 0306 5D9B      		rjmp .L149
 1118 0308 00C0      	.L69:
 1119               	.LBE239:
 1120               	.LBE238:
 1122 030c FCB9      	.LM152:
 1123               		cpi r25,lo8(115)
 1124               		brne .L72
 1125               	.L96:
 1126               	.LBB240:
 1127               	.LBB241:
 1129               	.LM153:
 1130 030e 5D9B      		sbis 43-32,5
 1131 0310 00C0      		rjmp .L96
 1133               	.LM154:
 1134 0312 28E3      		ldi r22,lo8(7)
 1135               		out 44-32,r22
 1136 0314 2CB9      	.L74:
 1137 0316 00C0      	.LBE241:
 1138               	.LBE240:
 1139               	.LBB242:
 1140               	.LBB243:
 665:main.c        **** if (val == 'E') 
 666:main.c        **** 			{
 667:main.c        **** 			address = readEEpromPage(address, size);
 668:main.c        **** 			}
 669:main.c        **** 
 670:main.c        **** 		// Chip erase
 671:main.c        ****  		} 
 672:main.c        **** 		else if (val == 'e') 
 1141               	LM154-.LFBB2
 1142               	.LM154:
 1143 0318 9337      		ldi r22,lo8(7)
 1144 031a 01F4      		out 44-32,r22
 1145               	.L74:
 1146               	.LBE241:
 1147               	.LBE240:
 1148               	.LBB242:
 1149               	.LBB243:
 1151 031e 00C0      	.LM155:
 1152               		sbis 43-32,5
 1153               		rjmp .L74
 1155 0322 6CB9      	.LM156:
 1156               		ldi r24,lo8(-109)
 1157               		out 44-32,r24
 1158               	.L75:
 1159               	.LBE243:
 1160               	.LBE242:
 1161               	.LBB244:
 1162               	.LBB245:
 1164 0326 00C0      	.LM157:
 1165               		sbis 43-32,5
 1166               		rjmp .L75
 1168 032a 8CB9      	.LM158:
 1169               		ldi r24,lo8(30)
 1170               		rjmp .L150
 1171               	.L72:
 1172               	.LBE245:
 1173               	.LBE244:
 1175               	.LM159:
 1176 032c 5D9B      		cpi r25,lo8(27)
 1177 032e 00C0      		brne .+2
 1178               		rjmp .L149
 1179               	.L97:
 1180 0330 8EE1      	.LBB246:
 1181 0332 00C0      	.LBB247:
 1183               	.LM160:
 1184               		sbis 43-32,5
 673:main.c        **** s = readEEpromPage(address, size);
 674:main.c        **** 			}
 675:main.c        **** 
 676:main.c        **** 		// Chip erase
 677:main.c        ****  		} 
 678:main.c        **** 		else if (val == 'e') 
 679:main.c        **** 		{
 680:main.c        **** 		if (device == DEVTYPE) 
 1185               	B247:
 1187 0334 9B31      	.LM160:
 1188 0336 01F4      		sbis 43-32,5
 1189 0338 00C0      		rjmp .L97
 1191               	.LM161:
 1192               		ldi r24,lo8(63)
 1193               	.L150:
 1194               		out 44-32,r24
 1195 033a 5D9B      		rjmp .L149
 1196 033c 00C0      	.LBE247:
 1197               	.LBE246:
 1242               	.Lscope2:
 1243               		.comm gBuffer,64,1
 1246               	.Letext0:
 1247               	.global __do_clear_bss
 1248               	...
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\DOCUME~1\user\LOCALS~1\Temp/cc7gFlAJ.s:2      *ABS*:0000003f __SREG__
C:\DOCUME~1\user\LOCALS~1\Temp/cc7gFlAJ.s:3      *ABS*:0000003e __SP_H__
C:\DOCUME~1\user\LOCALS~1\Temp/cc7gFlAJ.s:4      *ABS*:0000003d __SP_L__
C:\DOCUME~1\user\LOCALS~1\Temp/cc7gFlAJ.s:5      *ABS*:00000034 __CCP__
C:\DOCUME~1\user\LOCALS~1\Temp/cc7gFlAJ.s:6      *ABS*:00000000 __tmp_reg__
C:\DOCUME~1\user\LOCALS~1\Temp/cc7gFlAJ.s:7      *ABS*:00000001 __zero_reg__
C:\DOCUME~1\user\LOCALS~1\Temp/cc7gFlAJ.s:96     .text:00000000 __vector_default
C:\DOCUME~1\user\LOCALS~1\Temp/cc7gFlAJ.s:111    .text:00000002 main
                            *COM*:00000040 gBuffer

UNDEFINED SYMBOLS
__eewr_byte_m8
__eerd_byte_m8
__do_clear_bss
